//////// JSM: The custom-made assembly language for the TJSVMTDHAA
By Henry Ty, XX November 2022

general format: [prefix] [arg1] [arg2]

//// type definitions:
/comment: any text
    prefixed with '/' and ignored by compiler
$literal: any 16-bit hexadecimal number
    prefixed with '!' and replaced with values during compilation
!variable: any non-whitespace string
[addr]: address in memory, either a:
    [$literal]: hex literal
        or a
    [( expression )]: where an expression is either:
        $literal: hex literal
        ( ( expression ) +/-/* ( expression ) ): an expression, an operator (+, -, or *) and another expression
        *PARENTHETICAL EXPRESSIONS MUST BE SEPARATED WITH WHITESPACE* i.e. ($2 + $3) would throw an error: do ( $2 + $3 ) instead  
        **EXPRESSIONS ARE EVALUATED WITH STANDARD ORDER OF OPERATIONS, INCLUDING PARENTHESES**
reg: register name (acc, x, y, d)
&reg: reference the memory addressed by a register rather than the referencing the value of the register


//// special keywords:
.org $literal
    write the suceeding lines at the address
.def variable $literal
    define a variable with the variable name and the value $literal
    variables are referenced in other parts with !variable
    variables are replaced with their values during compilation. They are only found in the assembly and are not referenced in the machine code
.data8 name $lit1 $lit2... $litN
    write the following bytes directly into memory
    $literals must be 8 bits only
    !name is a variable that referenced the address in memory of $lit1
.data16 name $literal1 $literal2... $literalN
    ditto, but for 16bit literals

//// Commands
// mov A B: copy the value in A to B  (B = A)
    mov reg reg^
    mov $lit reg^
    mov reg [addr]^
    mov [addr] reg^
    mov $lit &reg^
    mov $lit [addr]^
    mov [addr] [addr]^

    mov &reg reg $lit*
        copy the value of memory the address of the value of a register + a literal to the register (B = [A + $lit])  
    mov reg &reg $lit*
        vice versa

    mov &reg reg*
    mov reg &reg*

    *format is only used for mov 
    ^formats are valid for every other commands

// add A B: copy A + B to the acc (acc = A + B)
// sub A B: copy A - B to the acc (acc = A - B)
// mul A B: copy A * B to the acc (acc = A * B)
// and A B: copy A & B to the acc (acc = A & B)
// or A B: copy A | B to the acc (acc = A | B)
// xor A B: copy A ^ B to the acc (acc = A ^ B)

// not A: bitwise not the register (A = ~A)
// neg A: 2's complement negate the register (A = -A)
// inc A: increment the register (A = A + 1)
// dec A: decrement the register (A = A - 1)

// shr A B: copy A >> B to the acc (acc = A >> B)
// shl A B: copy A << B to the acc (acc = A << B)

// jez/jlz/jgz/jnz address: jump to address if acc ==0/<0/>0/!=0
// jgt/jlt/jgz/jne A address: jump to address if acc ==A/<A/>A/!=A