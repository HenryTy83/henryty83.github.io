//////// TJSVMTDHAA: The Javascript Virtual Machine That Doesn't Have An Acronym


By Henry Ty, Aug 8-2X 2022
Following along (and partially copying) from Low Level Javascript's LLJS VM:  https://github.com/LowLevelJavaScript/16-Bit-Virtual-Machine


//// Hardware specs:
16-bit big endian Von Neumann architecture processor
registers:
    instruction pointer
    accumulator
    x, y, d, r3-r7 general purpose registers
    stack pointer (descending stack)
    frame pointer
    memory bank
    interupt mask
65536 ($ffff + 1) unique addresses (not including bank-switching)
Memory Mapped I/O

//// Memory Mapping:
0x0000-0x3ff0: program memory
0x3fee: Hardware interrupt address
0x3ff0-0x3fff: interrupt vector addresses
0x4000-0x7fff: general purpose use
< 0x7fff: stack
0x8000-0xafff: Peripherals 
    0x8000-0x87b7: screen display
        screen is mapped in rows from top to bottom, each row goes from left to right. each byte corresponds to a character 
        useable address space: 
        starting rows: 0x8000, 0x804e, 0x809c, 0x80ea
        the row at 0x8769 is cut off of the bottom. This place is where commands can be sent without messing with the picture
        high byte: 
            0xff: clear screen
            0x01: bold text
            0x02: italic text
            0x03: bold and italic text
        The value 0xffff will switch the screen to 'Unicode Mode', where each 16 bit value is treated as one unicode character. Write 0xffff to toggle back 
    0x8800: hardware interrupts
        A hardware interrupt will immediately make the processor jump, so long as it isn't currently in an interrupt. The value at 0x8800 is the address to the device that triggered the interrupt
            0x8802: keyboard
                read from the keyboard to clear the interrupt
    0xaffe-0xafff: sleep timer
        Write a nonzero 16 bit value (x) to the timer and it will immediately begin counting down (x*10 ms)
        After the timer expires, reading from the timer will yield the value x (if the timer is still running, reading will yield 0)
0xb000-0xffff: memory bank
    currently unused



//// Assembly documentation:
Programs must be inputted in the form of a long string with commands separated by whitespace

label:                                      referenced by [!label]
/ comment /                                 any text surrounded by / will be ignored

nop                                         do nothing
mov reg/$lit/&[addr], reg/&[addr]           mov value in first operand to location in second operand
mov $lit reg reg                            mov memory value at address &[lit + reg1] to reg2

add reg, reg/$lit                           add two operands, store result to acc
sub reg, reg/$lit                           sub second operand from the first operand, store result to acc
mul reg, reg/$lit                           multiply two operands, store result to acc
and reg, reg/$lit                           bitwise AND two operands, store result to acc
or reg, reg/$lit                            bitwise OR two operands, store result to acc
xor reg, reg/$lit                           bitwise XOR two operands, store result to acc
not reg                                     bitwise NOT selected register  
shl reg reg/$lit                            left shift selected register [second operator] times
shr reg reg/$lit                            right shift selected register [second operator] times
inc reg                                     increment selected register
dec reg                                     decrement selected register

jmp $addr/[!label]                          jump to operand
jgz $addr/[!label]                          jump to operand if acc > 0
jlz $addr/[!label]                          jump to operand if acc < 0
jez $addr/[!label]                          jump to operand if acc == 0
jnz $addr/[!label]                          jump to operand if acc != 0

jgt $lit/reg [!label]                       jump to second operand if acc > first operand
jlt $lit/reg [!label]                       jump to second operand if acc < first operand
jeq $lit/reg [!label]                       jump to second operand if acc == first operand
jne $lit/reg [!label]                       jump to second operand if acc != first operand

psh $lit/reg                               push the operand to the stack
pop reg                                     pop a value from the stack, store to selected regester

cal $lit/reg                                jump to subroutine at operand. Upon RET, every register except acc will be restored to previous value
ret                                         return from subroutine
rti                                         return from interrupt. Same as ret, just only used within interrupts

hlt                                         halt execution