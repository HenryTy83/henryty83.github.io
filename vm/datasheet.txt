//////// TJSVMTDHAA: The Javascript Virtual Machine That Doesn't Have An Acronym


By Henry Ty, Aug 1X 2022
Following along (and partially copying) from Low Level Javascript's LLJS VM:  https://github.com/LowLevelJavaScript/16-Bit-Virtual-Machine


//// Hardware specs:
16-bit big endian Von Neumann architecture processor
registers:
    instruction pointer
    accumulator
    x, y, d, r3-r7 general purpose registers
    stack pointer
    frame pointer
    memory bank
    interupt mask
65536 ($ffff) unique addresses (not including bank-switching)
Memory Mapped I/O

//// Memory Mapping:
0x0000-0x3ff0: program memory
0x3fee: Hardware interrupt address
0x3ff0-0x3fff: interrupt vector addresses
0x4000-0x7fff: general purpose use
< 0x7fff: stack
0x8000-0xafff: Peripherals 
    0x8000-0x87b7: screen display
        screen is mapped in rows from top to bottom, each row goes from left to right. each byte corresponds to a character 
        useable address space: 
        starting rows: 0x8000, 0x804e, 0x809c, 0x80ea
        the row at 0x8769 is cut off of the bottom. This place is where commands can be sent without messing with the picture
        high byte: 
            0xff: clear screen before writing
            0x01: bold text
            0x02: italic text
            0x03: bold and italic text 
    0x8800: io
0xb000-0xffff: memory bank
    mb = 0: VRAM

//// Assembly documentation:
Programs must be inputted in the form of a long string with commands separated by whitespace

nop                                         do nothing
mov reg/$lit/&[addr], reg/&[addr]           mov value in first operand to location in second operand

add reg/$lit, reg                           add two operands, store result to acc
sub reg/$lit, reg                           sub second operand from the first operand, store result to acc
mul reg/$lit, reg                           multiply two operands, store result to acc
and reg/$lit, reg                           bitwise AND two operands, store result to acc
or reg/$lit, reg                            bitwise OR two operands, store result to acc
xor reg/$lit, reg                           bitwise XOR two operands, store result to acc
not reg                                     bitwise NOT selected register  
lsh reg                                     left shift selected register
rsh reg                                     right shift selected register
inc reg                                     increment selected register
dec reg                                     decrement selected register

jmp &[addr]                                 jump to operand
jgz &[addr]                                 jump to operand if acc > 0
jlz &[addr]                                 jump to operand if acc < 0
jez &[addr]                                 jump to operand if acc == 0
jnz &[addr]                                 jump to operand if acc != 0

jgt $lit/reg &[addr]                        jump to second operand if acc > first operand
jlt $lit/reg &[addr]                        jump to second operand if acc < first operand
jeq $lit/reg &[addr]                        jump to second operand if acc == first operand
jne $lit/reg &[addr]                        jump to second operand if acc != first operand

push $lit/reg                               push the operand to the stack
pop reg                                     pop a value from the stack, store to selected regester

cal $lit/reg                                jump to subroutine at operand
ret                                         return from subroutine

hlt                                         halt execution